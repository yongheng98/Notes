# 面试问题

## Java基础

### 1、Java的特点

​		Java具有简单性、面向对象、[分布式](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F/19276232)、[健壮性](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%81%A5%E5%A3%AE%E6%80%A7)、[安全性](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%AE%89%E5%85%A8%E6%80%A7)、平台独立与可移植性、[多线程](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B)、动态性等特点 。Java可以编写[桌面应用程序](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)、[Web应用程序](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)、[分布式系统](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F)和[嵌入式系统](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F)应用程序等。

### 2、Java的面向对象

面向对象的四大特征：**抽象**、**封装**、**继承**、**多态**

**抽象**：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。

**封装**：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。**原则**：将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。

- **封装的操作步骤**
  - 使用 private 关键字来修饰成员变量。
  - 对需要访问的成员变量，提供对应的一对 `getXxx()` 方法 、 `setXxx()` 方法。

**继承**：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。

- **继承的优点**：

  - 提高代码的复用性。
  -  类与类之间产生了关系，是多态的前提。

- **继承的特点**：

  - Java只支持单继承，不支持多继承。
  - Java支持多层继承。顶层父类是Object类。所有的类默认继承Object，作为父类。

- **super和this的含义**：
     super ：代表父类的存储空间标识(可以理解为父亲的引用)。
     this ：代表当前对象的引用(谁调用就代表谁)。

  ​	注意：子类的每个构造方法中都有默认的`super()` ，调用父类的空参构造。手动调用父类构造会覆盖默认的`super()`。

  ​	`super()` 和 `this()` 都必须出现在构造方法的第一行，所以不能同时出现。

**多态**：多态性是指允许不同子类型的对象对同一消息作出不同的响应。**简单的说就是用同样的对象引用调**
**用同样的方法但是做了不同的事情。** **多态性分为编译时的多态性和运行时的多态性。**如果将对象的方法视为对象向外
界提供的服务，那么运行时的多态性可以解释为：当 A 系统访问 B 系统提供的服务时， B 系统有多种提供服务的方式，
但一切对 A 系统来说都是透明的。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写
（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做
两件事： 1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）； 2. 对象造型（用**父类型引用引用子类型对**
**象**，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。

### 3、方法重载（overload） 与 方法重写（override）



**方法重载：** **重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。**

每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

最常用的地方就是构造器的重载。

- 被重载的方法必须改变参数列表(参数个数或类型不一样)；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。
- 无法以返回值类型作为重载函数的区分标准。



**方法重写**：重写是子类对父类的允许访问的方法的实现过程进行重新编写, **返回值和形参都不能改变**。**即外壳不变，核心重写！**

重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。

重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。

- 参数列表与被重写方法的参数列表必须完全相同。
- 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
- 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
- 父类的成员方法只能被它的子类重写。
- 声明为 final 的方法不能被重写。
- 声明为 static 的方法不能被重写，但是能够被再次声明。
- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
- 构造方法不能被重写。
- 如果不能继承一个类，则不能重写该类的方法。



### 4、接口 interface

类描述对象的属性和方法。接口则包含类要实现的方法。

**除非实现接口的类是抽象类，否则该类要定义接口中的所有方法**。接口是隐式抽象的，变量默认为`public static final`，方法默认为 `public abstract`

**接口无法被实例化，但是可以被实现（无法new接口，可以implements接口）**。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，**接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象**。例如，`List<Integer> list = new LinkedList<>();` .



**接口与类相似点**：

- 一个接口可以有多个方法。
- 接口文件保存在 .java 结尾的文件中，文件名使用接口名。
- 接口的字节码文件保存在 .class 结尾的文件中。
- 接口相应的字节码文件必须在与包名称相匹配的目录结构中。



**接口与类的区别**：

- 接口不能用于实例化对象。
- 接口没有构造方法。
- 接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。
- 接口不能包含成员变量，除了 static 和 final 变量。
- 接口不是被类继承了，而是要被类实现。
- 接口支持多继承。



**接口特性**

- 接口中每一个方法也是**隐式抽象**的,接口中的方法会被隐式的指定为 **public abstract**（只能是 public abstract，其他修饰符都会报错）。
- 接口中可以含有变量，但是接口中的变量会被隐式的指定为 **public static final** 变量（并且只能是 public，用 private 修饰会报编译错误）。
- 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。（JDK 8 以后可以）



**抽象类和接口的区别**

- 1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
- 2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 **public static final** 类型的。
- 3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
- 4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

```
注：JDK 1.8 以后，接口里可以有静态方法和方法体了。

注：JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为"默认方法"，默认方法使用 default 关键字修饰。更多内容可参考 Java 8 默认方法。

注：JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。更多内容可参考 Java 9 私有接口方法
```



### 5、抽象类 abstract class

​		在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。

​		抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。

​		在 Java 中**抽象类表示的是一种继承关系**，一个类只能继承一个抽象类，而一个类却可以实现多个接口。

**抽象类总结**

- 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。**只有抽象类的非抽象子类可以创建对象**。
- 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
- 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
- **构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。**
- 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

```java
public abstract class Employee // 抽象类
{
   private String name;
   private String address;
   private int number;
   
   public abstract double computePay(); // 抽象方法，包含抽象方法的类必须为抽象类
   
   //其余代码
}
```



### 6、线程池

Java线程的生命周期，线程池的执行过程，应用，各种策略，锁

https://blog.csdn.net/qq_40093255/article/details/116990431

https://blog.csdn.net/xingjing1226/article/details/81977129