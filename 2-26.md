## 2-26 6

095.最长公共子序列

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        // 只关心最优值，动态规划 双序列
        // 设dp[i][j] 为s1[0~i] 与 s2[0~j]的最长公共子序列，最终答案为dp[s1.length][s2.length]
        // 空间应该还可以优化
        int n = text1.length();
        int m = text2.length();

        int[][] dp = new int[n][m];
        
        // 初始化 第一行 和 第一列
        for(int i = 0; i < m; i++)
        {
            if(text1.charAt(0) == text2.charAt(i))
            {
                while(i < m) dp[0][i++] = 1;
                break;
            }
            else
            {
                dp[0][i] = 0;
            }
        }
        for(int i = 0; i < n; i++)
        {
            if(text2.charAt(0) == text1.charAt(i))
            {
                while(i < n) dp[i++][0] = 1;
                break;
            }
            else
            {
                dp[i][0] = 0;
            }
        }

        // 迭代
        for(int i = 1; i < n; i++)
        {
            for(int j = 1; j < m; j++)
            {
                if(text1.charAt(i) == text2.charAt(j))
                {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else
                {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[n - 1][m - 1];
    }
}
```



097.子序列的数目

```java
class Solution {
    public int numDistinct(String s, String t) {
        // 只关心最优值，动态规划 双序列
        // dp[i][j] 为 s[0~i]的字符串的所有以i结尾的子序列 包含t[0~j]子串的数目
        // dp[i][j] = dp[i-1][j-1] + dp[i-1][j], s[i] == t[j], 
        // 重点是初始化，第一行 和 第一列
        int n = s.length();
        int m = t.length();
        int[][] dp = new int[n][m];

        // 初始化
        if(s.charAt(0) == t.charAt(0)) dp[0][0] = 1; // 初始化 第一行
        
        for(int i=1;i<n;i++) // 初始化 第一列
        {
            if(s.charAt(i) == t.charAt(0))
            {
                dp[i][0] = dp[i - 1][0] + 1;
            }
            else
            {
                dp[i][0] = dp[i - 1][0];
            }
        }

        // 迭代
        for(int i = 1; i < n; i++)
        {
            for(int j = 1; j < m; j++)
            {
                if(i < j) break;
                if(s.charAt(i) == t.charAt(j)) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                else dp[i][j] = dp[i - 1][j]; 
            }
        }
        /*System.out.println(dp);
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                System.out.print(dp[i][j] + " ");
            }
            System.out.println();
        }*/
        return dp[n - 1][m - 1];
    }
}
```



098.路径的数目

```java
class Solution {
    public int uniquePaths(int m, int n) {
        // 只关心路径的数目，动态规划
        // dp[i][j] 为 从(0,0) 到 (i,j) 的 路径的数目
        // dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        // 初始化 第一行 和 第一列
        int[][] dp = new int[m][n];

        // 初始化
        for(int i = 0; i < n; i++) dp[0][i] = 1;
        for(int i = 0; i < m; i++) dp[i][0] = 1;

        // 迭代
        for(int i = 1; i < m; i++)
        {
            for(int j = 1; j < n; j++)
            {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        return dp[m - 1][n - 1];
    }
}
```



099.最小路径和

```java
class Solution {
    public int minPathSum(int[][] grid) {
        // 只关心最优值，动态规划 或者 回溯也可以
        // dp[i][j] 为 从(0, 0) 到 (i, j) 的最小的路径和，则ans = dp[n - 1][m - 1];
        // dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]); 对于每个格子只会从上方和左方来
        // 初始化 第一行和第一列
        int n = grid.length;
        int m = grid[0].length;
        int[][] dp = new int[n][m];

        // 初始化
        dp[0][0] = grid[0][0];
        for(int i = 1; i < m; i++) dp[0][i] = dp[0][i - 1] + grid[0][i];
        for(int i = 1; i < n; i++) dp[i][0] = dp[i - 1][0] + grid[i][0];

        // 迭代
        for(int i = 1; i < n; i++)
        {
            for(int j = 1; j < m; j++)
            {
                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
            }
        }

        return dp[n - 1][m - 1];
    }
}
```



100.三角形中最小路径之和

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        // 只关心最优值，动态规划 回溯也可以
        // dp[i][j] 为 从 (0,0) 到 (i, j) 的 路径的最小和, 则ans为最后一行中的最小值
        // dp[i][j] = Math.min(dp[i-1][j-1], dp[i-1][j]) + triangle.get(i).get(j);
        // 初始化 左右列
        int n = triangle.size();
        int m = triangle.get(n - 1).size();
        int[][] dp = new int[n][m];

        // 初始化
        dp[0][0] = triangle.get(0).get(0);
        for(int i = 1; i < n; i++)
        {
            dp[i][0] = dp[i - 1][0] + triangle.get(i).get(0);
        }
        for(int i = 1; i < n; i++)
        {
            dp[i][i] = dp[i - 1][i - 1] + triangle.get(i).get(i);
        }

        // 迭代
        for(int i = 2; i < n; i++)
        {
            for(int j = 1; j < i; j++)
            {
                dp[i][j] = Math.min(dp[i-1][j-1], dp[i-1][j]) + triangle.get(i).get(j);
            }
        }
        int ans = Integer.MAX_VALUE;
        for(int i = 0; i < m; i++)
        {
            if(ans > dp[n - 1][i]) ans = dp[n - 1][i];
        }
        return ans;
        
    }
}
```



105.岛屿的最大面积

```java
class Solution {
    int[][] d = {{1,0},{-1,0},{0,1},{0,-1}};
    public int dfs (int[][] grid, int ii, int jj)
    {
        int cnt = 0;
        int n = grid.length;
        int m = grid[0].length;
        if(ii >= 0 && ii < n && jj >= 0 && jj < m && grid[ii][jj] == 1)
        {
            //vis[ii][jj] = true;
            grid[ii][jj] = 0;
            cnt = 1;
            // 
            for(int i = 0; i < 4; i++)
            {
                int x = ii + d[i][0];
                int y = jj + d[i][1];

                cnt += dfs(grid, x, y);
            }
            // return cnt;
        }
        return cnt;
    }
    public int maxAreaOfIsland(int[][] grid) {
        // 图 dfs
        int n = grid.length;
        int m = grid[0].length;
        int ans = 0;
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                if(grid[i][j] == 1)
                {
                    ans = Math.max(ans, dfs(grid,i,j));
                }
            }
        }
        return ans;
    }
}
```

## 2-27 

### 图论

110.所有路径

```java
class Solution {
    public void dfs(int[][] graph, int s, int e, LinkedList<Integer> temp, List<List<Integer>> ans)
    {
        if(s == e)
        {
            ans.add(new LinkedList<Integer>(temp));
        }
        // 加入 s 点
        for(int i=0;i<graph[s].length;i++)
        {
            temp.add(graph[s][i]);
            dfs(graph, graph[s][i], e, temp, ans);
            temp.removeLast();
        }
    }
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        // 深度优先遍历 dfs
        // 请找到所有从 0 到 n-1 的路径并输出
        int n = graph.length;
        List<List<Integer>> ans = new LinkedList<>();
        LinkedList<Integer> temp = new LinkedList<>();
        
        temp.add(0);
        dfs(graph, 0, n - 1, temp, ans);
        //temp.removeLast();
          
        return ans;
    }
}
```

