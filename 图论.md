# 图论

## 基础知识

**图的分类**：有向图 和 无向图。有权图 和 无权图。

**存储方式**：邻接表 和 邻接矩阵存储。

- 邻接表：图中的每个节点，创建一个容器，第i个容器保存所有与第i个结点相连的结点。（无向图，存储两遍）适合存储稀疏图。
- 邻接矩阵：有n个结点的图的邻接矩阵是一个nxn的矩阵。如果`M[i][j]=1` 说明有一条边从i号节点到j号节点。适合存储稠密图（边比较多的图）。

**图的搜索**：深度优先搜索 和 广度优先搜索。

**特点**：

如果题目要求在无权图中找出两个结点之间的最短距离，适合广度优先搜索；

如果题目要求找出符合条件的路径，适合深度优先搜索。



**双向广度优先搜索**可以用来缩小从单一起始节点、单一目标节点的最短距离问题。能够缩小搜索空间，从而提高搜索效率。

## 应用		

- 105.最大的岛屿

  ```java
  
  ```

- 106.二分图

  可能有多个连通子图，必须每一个都是二分图，整体才是二分图。所以需要单独判断每一个子图是否为二分图。

  ```java
  class Solution {
      public boolean fun (int[][] graph, int[] vis, int index) // 可能有多个连通子图，判断每一个
      {
          Queue<Integer> q = new LinkedList<>();
          vis[index] = 0;
          q.offer(index);
          while(!q.isEmpty())
          {
              int len = q.size();
              for(int i = 0; i < len; i++)
              {
                  int t = q.poll();
                  int m = graph[t].length;
                  for(int j = 0; j < m; j++)
                  {
                      int node = graph[t][j];
                      if(vis[node] == -1) // 之前没有遍历过
                      {
                          vis[node] = 1 - vis[t]; // 
                          q.offer(node); // 加入队列
                      } 
                      else if(vis[node] == vis[t]) return false; // 
                  }
              }
          }
          return true;
      }
      public boolean isBipartite(int[][] graph) {
          // 染色法
          // 遍历图，染色0，所有与0相邻的结点染色1;如果之前已经染过色了,判断是否是0色，false continue
          // 广度优先遍历
          int n = graph.length;
          int[] vis = new int[n];
          Arrays.fill(vis, -1); // 初始化 -1，表示没有遍历过i号节点
          
          // [[1,2], [0], [0], [4,5], [3,5], [3,4]] 两个连通图，一个是，一个不是二分图
          
          for(int i = 0; i < n; i++)
          {
              if(vis[i] == -1)
              {
                  if(!fun(graph, vis, i)) return false;
              }
          }
          return true;
      }
  }
  ```

  

108.单词演变

解题关键是找到点（什么表示点）和边（什么表示边）对应的关系。

**双向广度优先搜索**可以用来缩小从单一起始节点、单一目标节点的最短距离问题。能够缩小搜索空间，从而提高搜索效率。

```java
// 单向广度优先搜索
class Solution {
    public List<String> getNeighbors(String word)
    {
        List<String> neighbors = new LinkedList<>();
        char[] chars = word.toCharArray();
        for(int i = 0; i < chars.length; i++)
        {
            char old = chars[i];
            for(char ch = 'a'; ch <= 'z'; ch++)
            {
                if(old != ch)
                {
                    chars[i] = ch;
                    neighbors.add(new String(chars));
                }
            }
            chars[i] = old;
        }
        return neighbors;
    }
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
       // 建图，结点为单词，边为是否能通过变一个字符实现相等
       // 深度优先搜索
       Queue<String> q1 = new LinkedList<>();
       Queue<String> q2 = new LinkedList<>();
       Set<String> notVis = new HashSet<>(wordList);

       int length = 0;
       q1.offer(beginWord);
       while(!q1.isEmpty())
       {
            int n = q1.size();
            length++;
            for(int i = 0; i < n; i++)
            {
                String word = q1.poll();
                if(word.equals(endWord)) return length;
                List<String> neighbors = getNeighbors(word);
                for(String nei : neighbors)
                {
                    if(notVis.contains(nei))
                    {
                        notVis.remove(nei);
                        if(nei.equals(endWord)) return length + 1;
                        q1.offer(nei);
                    }
                }
            }           
       }
       return 0;

    }
}

// 双向广度优先搜素
class Solution {
    public List<String> getNeighbors(String word)
    {
        List<String> neighbors = new LinkedList<>();
        char[] chars = word.toCharArray();
        for(int i = 0; i < chars.length; i++)
        {
            char old = chars[i];
            for(char ch = 'a'; ch <= 'z'; ch++)
            {
                if(old != ch)
                {
                    chars[i] = ch;
                    neighbors.add(new String(chars));
                }
            }
            chars[i] = old;
        }
        return neighbors;
    }
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> notVis = new HashSet<>(wordList);
        if(!notVis.contains(endWord)) return 0;

        Set<String> set1 = new HashSet<>();
        Set<String> set2 = new HashSet<>();
        int length = 2;
        set1.add(beginWord); // 存放当前方向需要访问的节点
        set2.add(endWord);
        notVis.remove(endWord);
        while(!set1.isEmpty() && !set2.isEmpty())
        {
            if(set2.size() < set1.size()) // 每次while循环都是从需要访问节点数目少的方向搜索，目的是减小搜索空间。
            {
                Set<String> temp = set1;
                set1 = set2;
                set2 = temp;
            }
            Set<String> set3 = new HashSet<>();
            for(String word : set1) // 访问set1中的每个节点
            {
                List<String> neighbors = getNeighbors(word); // 获取每个节点的相邻的节点
                for(String nei : neighbors) // 遍历相邻的节点
                {
                    if(set2.contains(nei)) return length; // 如果相邻的节点在set2中，找到一条路径，返回长度
                    if(notVis.contains(nei)) // 没在set2中，
                    {
                        set3.add(nei); // 放入set3，待遍历的set1
                        notVis.remove(nei); // 设置为遍历过。
                    }
                }
            }
            length ++;
            set1 = set3;
        }
        return 0;
    }
}
```



109.开锁密码

```java
// 单向广度优先搜索
class Solution {
    public List<String> getNeighbors(String word)
    {
        List<String> neighbors = new LinkedList<>();
        for(int i = 0; i < word.length(); i++)
        {
            char ch = word.charAt(i);

            char newchar = ch == '0' ? '9':(char)(ch - 1);
            StringBuilder sb = new StringBuilder(word);
            sb.setCharAt(i, newchar);
            neighbors.add(sb.toString());

            newchar = ch == '9'?'0':(char)(ch + 1);
            sb.setCharAt(i, newchar);
            neighbors.add(sb.toString());
        }
        return neighbors;
    }
    public int openLock(String[] deadends, String target) {
        // 
        Set<String> dead = new HashSet<>(Arrays.asList(deadends));
        Set<String> notVis = new HashSet<>(); // 已经遍历过的元素 

        String init = "0000";
        if(dead.contains(init) || dead.contains(target)) return -1; // ???

        Queue<String> q1 = new LinkedList<>();
        Queue<String> q2 = new LinkedList<>();

        int step = 0;
        q1.offer(init);
        notVis.add(init);
        while(!q1.isEmpty())
        {
            String cur = q1.remove();
            if(cur.equals(target)) return step;

            List<String> neighbors = getNeighbors(cur);
            for(String nei : neighbors)
            {
                if(!dead.contains(nei) && !notVis.contains(nei))
                {
                    q2.offer(nei);
                    notVis.add(nei);
                }
            }

            if(q1.isEmpty())
            {
                step ++;
                q1 = q2;
                q2 = new LinkedList<>();
            }
        }
        return -1;
    }
}

// 双向广度优先搜索 减小搜索空间
class Solution {
    public List<String> getNeighbors(String word)
    {
        List<String> neighbors = new LinkedList<>();
        for(int i = 0; i < word.length(); i++)
        {
            char ch = word.charAt(i);

            char newchar = ch == '0' ? '9':(char)(ch - 1);
            StringBuilder sb = new StringBuilder(word);
            sb.setCharAt(i, newchar);
            neighbors.add(sb.toString());

            newchar = ch == '9'?'0':(char)(ch + 1);
            sb.setCharAt(i, newchar);
            neighbors.add(sb.toString());
        }
        return neighbors;
    }
    public int openLock(String[] deadends, String target) {
        // 
        Set<String> dead = new HashSet<>(Arrays.asList(deadends));
        Set<String> visted = new HashSet<>(); // 已经遍历过的元素 

        String init = "0000";
        if(target.equals("0000")) return 0;
        if(dead.contains(init) || dead.contains(target)) return -1; // ???

        Set<String> s1 = new HashSet<>();
        Set<String> s2 = new HashSet<>();

        int step = 1;
        s1.add(init);
        s2.add(target);
        visted.add(init);
        // visted.add(target);
        while(!s1.isEmpty() && !s2.isEmpty())
        {
            if(s1.size() > s2.size())
            {
                Set<String> t = s1;
                // s3 = s1;
                s1 = s2;
                s2 = t;
            }
            
            Set<String> s3 = new HashSet<>();
            for(String word : s1)
            {
                List<String> neighbors = getNeighbors(word);
                for(String nei : neighbors)
                {
                    if(s2.contains(nei)) return step;
                    if(!dead.contains(nei) && !visted.contains(nei))
                    {
                        s3.add(nei);
                        visted.add(nei);
                    }
                }
            }
            step ++;
            s1 = s3;
        }
        return -1;
    }
}
```



113.课程顺序

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // 拓扑排序
        if(numCourses == 1) // 不存在有向的关系
        {
            int[] res = new int[]{0};
            return res;
        }
        // 初始化 有向图
        Map<Integer, LinkedList<Integer>> g = new HashMap<>();
        Map<Integer, Integer> in_dgree = new HashMap<>(); // key 点 ，value 入度
        for(int i = 0; i < prerequisites.length; i++)
        {
            int a = prerequisites[i][0];
            int b = prerequisites[i][1];
            // b->a
            if(g.containsKey(b))
            {
                g.get(b).add(a);
            }
            else
            {
                LinkedList<Integer> t = new LinkedList<>();
                t.add(a);
                g.put(b, t);
            }
            // 统计a点的入度
            in_dgree.put(a, in_dgree.getOrDefault(a, 0) + 1); // 一定>=1
            if(!in_dgree.containsKey(b)) in_dgree.put(b, 0); // 可能为0
        }
        for(int i = 0; i < numCourses; i++)
        {
            if(!in_dgree.containsKey(i)) in_dgree.put(i, 0);
        }

        // 统计入度 入度为0，入队
        Queue<Integer> q = new LinkedList<>();
        Set<Integer> visted = new HashSet<>();
        //List<List<Integer>> ans = new LinkedList<LinkedList<>>();
        LinkedList<Integer> ans = new LinkedList<>();
        for(Map.Entry entry : in_dgree.entrySet())
        {
            int key = (Integer)entry.getKey();
            int value = (Integer)entry.getValue();
            if(value == 0)
            {
                q.offer(key);
                visted.add(key); // 遍历过 key点,入度为0的点
            } 
        }

        while(!q.isEmpty())
        {
            int a = q.poll(); // a点入度为0，找到所有与a点相连的点,a->b,所有b点入度-1
            // System.out.println(a);
            ans.add(a);
            List<Integer> list = g.get(a); // a点连接的所有点
            if(list == null) continue;
            for(int i = 0; i < list.size(); i++)
            {
                int l = list.get(i);
                if(!visted.contains(l))
                {
                    in_dgree.put(l, in_dgree.get(l) - 1);
                    if(in_dgree.get(l) == 0)
                    {
                        q.offer(l);
                        visted.add(l);
                    }
                }
            }
        }
        
        if(ans.size() == numCourses)
        {
            int[] res = new int[ans.size()];
            for(int i = 0; i < numCourses; i++)
            {
                res[i] = ans.get(i);
            }
            return res;
        }
        return new int[0];
    }
}
```

114.外星文字典

```java
class Solution {
    public String alienOrder(String[] words) {
        Map<Character, Set<Character>> graph = new HashMap<>(); // 存储有向图
        Map<Character, Integer> inDegrees = new HashMap<>(); // 记录字符的入度
        for(String word : words) // 建图
        {
            for(char ch : word.toCharArray())
            {
                graph.putIfAbsent(ch, new HashSet<Character>()); // 当key不存在时，插入键值对.对所有不重复的键建立有向边
                inDegrees.putIfAbsent(ch, 0); // 初始化，所有字符的入度为0
            }
        }
        for(int i = 1; i < words.length; i++)
        {
            String w1 = words[i - 1]; // 前一个字符串
            String w2 = words[i]; // 当前字符串
            // startsWith() 方法用于检测字符串是否以指定的前缀开始。
            if(w1.startsWith(w2) && !w1.equals(w2)) // w1 应该在 w2 的后边，顺序错误，无法排序，返回""
            {
                return "";
            }
            // 此时的排序顺序，合法
            for(int j = 0; j < w1.length() && j < w2.length(); j++) // j < Math.min(w1.length(), w2.length())
            {
                char ch1 = w1.charAt(j);
                char ch2 = w2.charAt(j);
                if(ch1 != ch2) // 找到 第一个不同的字符
                {
                    if(!graph.get(ch1).contains(ch2)) // 建立一条 ch1 -> ch2 的有向边
                    {
                        graph.get(ch1).add(ch2);
                        inDegrees.put(ch2, inDegrees.get(ch2) + 1); // ch2 的入度加 1
                    }
                    break;
                }
            }
        }

        Queue<Character> queue = new LinkedList<>();
        for(char ch : inDegrees.keySet()) // 遍历所有节点的入度，找入度为0的节点
        {
            if(inDegrees.get(ch) == 0)
            {
                queue.add(ch);
            }
        }

        StringBuilder sb = new StringBuilder(); 
        while(!queue.isEmpty())
        {
            char ch = queue.remove(); // 出队
            sb.append(ch); // 拼接
            for(char next : graph.get(ch)) // 所有ch 指向的 有向边，入度 -1
            {
                inDegrees.put(next, inDegrees.get(next) - 1); // 入度 -1
                if(inDegrees.get(next) == 0) queue.offer(next); // 
            }
        }

        return sb.length() == graph.size() ? sb.toString() : ""; // 不重复的字符的数量 都可以排序
    }
}
```

115.重建序列

```java
class Solution {
    public boolean sequenceReconstruction(int[] org, List<List<Integer>> seqs) {
            // 有向图的拓扑排序
            Map<Integer, Set<Integer>> g = new HashMap<>(); // 有向图
            Map<Integer, Integer> inDegree = new HashMap<>(); // 统计入度
            Set<Integer> node = new HashSet<>(); // 统计节点
            // if(org.length == 1) return true;
            // 遍历seqs
            for(int i = 0; i < seqs.size(); i++)
            {
                List<Integer> list = seqs.get(i);
                if(list.size() == 1)
                {
                    int a = list.get(0);
                    if(!node.contains(a)) inDegree.putIfAbsent(a, 0);
                    node.add(a);
                }
                for(int j = 1; j < list.size(); j++)
                {
                    int a = list.get(j - 1);
                    int b = list.get(j); // a- > b
                    if(!node.contains(a)) inDegree.putIfAbsent(a, 0);
                    node.add(a);
                    node.add(b);
                    g.putIfAbsent(a, new HashSet<Integer>());
                    
                    if(!g.get(a).contains(b)) // a -> b 之前没出现过
                    {
                        inDegree.put(b, inDegree.getOrDefault(b, 0) + 1); 
                    }
                    Set<Integer> temp = g.get(a);
                    temp.add(b);
                    g.put(a, temp);
                }
            }

            // 查看建的有向图是否正确
            /*for(Map.Entry<Integer, Set<Integer>> entry : g.entrySet())
            {
                System.out.print(entry.getKey());
                System.out.print(":");
                for(Integer s : entry.getValue())
                {
                    System.out.print(s);
                    System.out.print(" ");
                }
            }*/

            // 
            Queue<Integer> q = new LinkedList<>();
            for(Map.Entry<Integer, Integer> entry : inDegree.entrySet())
            {
                if(entry.getValue() == 0) q.offer(entry.getKey());
            }
            if(q.size() > 1) return false;
            List<Integer> ans = new LinkedList<>();
            while(!q.isEmpty())
            {
                int a = q.poll(); // a的入度为0
                ans.add(a);
                Set<Integer> temp = g.get(a);
                int cnt = 0;
                if(temp == null) continue;
                for(Integer b : temp)
                {
                    inDegree.put(b, inDegree.get(b) - 1);
                    if(inDegree.get(b) == 0)
                    {
                        cnt++;
                        if(cnt > 1) return false;
                        q.offer(b);
                    }
                }
                
            }
            /*for(int i = 0; i < ans.size(); i++)
            {
                System.out.print(ans.get(i));
            }*/
            // System.out.println();
            // if(ans.size() != org.length) return false;
            if(ans.size() == org.length && node.size() == org.length)
            {
                for(int i = 0; i < org.length; i++)
                {
                    if(org[i] != ans.get(i)) return false; 
                }
                return true;
            }
            return false;
    }
}
```



116.省份数量

```java
// 方法一：深度优先遍历 时间O(n^2) ，广度优先遍历也可以
class Solution {
    public void set_visted(int[][] citys, int start, boolean[] visted)
    {
        for(int i = 0; i < citys[start].length; i++)
        {
            if(citys[start][i] == 1 && !visted[i]) // j与i直接相连 并且 j之前没有遍历过
            {
                visted[i] = true;
                set_visted(citys, i, visted); // 递归遍历所有与j相连的节点，置为访问过
            }
        }
    }
    public int findCircleNum(int[][] citys) {
        // 连通图的数量 无向图
        boolean[] visted = new boolean[citys.length];
        int ans = 0;
        for(int i = 0; i < citys.length; i++)
        {
            if(!visted[i]) // 第i个城市没有被遍历过
            {
                ans++;
                visted[i] = true;
                set_visted(citys, i, visted);
            }
        }
        return ans;
    }
}

// 方法二：并查集
class Solution {
    private int findFather(int[] father, int i) // 找出i节点的根节点
    {
        if(father[i] != i)
        {
            father[i] = findFather(father, father[i]);
        }
        return father[i];
    }
    public boolean union(int[] father, int i, int j)
    {
        // 此时，有i与j直接相连
        int fatherOfI = findFather(father, i);
        int fatherOfJ = findFather(father, j);
        if(fatherOfI != fatherOfJ) // 具有不同的根
        {
            father[fatherOfI] = fatherOfJ;
            return true;
        }
        return false; // 有相同的根
    }
    public int findCircleNum(int[][] citys) {
        int[] father = new int[citys.length];
        for(int i = 0; i < citys.length; i++)
        {
            father[i] = i;
        }
        int count = citys.length;
        for(int i = 0; i < citys.length; i++)
        {
            for(int j = i + 1; j < citys[i].length; j++)
            {
                if(citys[i][j] == 1 && union(father, i, j))
                {
                    count --;
                }
            }
        }
        return count;
    }
}
```

