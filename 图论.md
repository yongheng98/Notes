# 图论

## 基础知识

**图的分类**：有向图 和 无向图。有权图 和 无权图。

**存储方式**：邻接表 和 邻接矩阵存储。

- 邻接表：图中的每个节点，创建一个容器，第i个容器保存所有与第i个结点相连的结点。（无向图，存储两遍）适合存储稀疏图。
- 邻接矩阵：有n个结点的图的邻接矩阵是一个nxn的矩阵。如果`M[i][j]=1` 说明有一条边从i号节点到j号节点。适合存储稠密图（边比较多的图）。

**图的搜索**：深度优先搜索 和 广度优先搜索。

**特点**：

如果题目要求在无权图中找出两个结点之间的最短距离，适合广度优先搜索；

如果题目要求找出符合条件的路径，适合深度优先搜索。



## 应用		

- 105.最大的岛屿

  ```java
  ```

- 106.二分图

  可能有多个连通子图，必须每一个都是二分图，整体才是二分图。所以需要单独判断每一个子图是否为二分图。

  ```java
  class Solution {
      public boolean fun (int[][] graph, int[] vis, int index) // 可能有多个连通子图，判断每一个
      {
          Queue<Integer> q = new LinkedList<>();
          vis[index] = 0;
          q.offer(index);
          while(!q.isEmpty())
          {
              int len = q.size();
              for(int i = 0; i < len; i++)
              {
                  int t = q.poll();
                  int m = graph[t].length;
                  for(int j = 0; j < m; j++)
                  {
                      int node = graph[t][j];
                      if(vis[node] == -1) // 之前没有遍历过
                      {
                          vis[node] = 1 - vis[t]; // 
                          q.offer(node); // 加入队列
                      } 
                      else if(vis[node] == vis[t]) return false; // 
                  }
              }
          }
          return true;
      }
      public boolean isBipartite(int[][] graph) {
          // 染色法
          // 遍历图，染色0，所有与0相邻的结点染色1;如果之前已经染过色了,判断是否是0色，false continue
          // 广度优先遍历
          int n = graph.length;
          int[] vis = new int[n];
          Arrays.fill(vis, -1); // 初始化 -1，表示没有遍历过i号节点
          
          // [[1,2], [0], [0], [4,5], [3,5], [3,4]] 两个连通图，一个是，一个不是二分图
          
          for(int i = 0; i < n; i++)
          {
              if(vis[i] == -1)
              {
                  if(!fun(graph, vis, i)) return false;
              }
          }
          return true;
      }
  }
  ```

  