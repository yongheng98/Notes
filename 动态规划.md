# 动态规划

## 基础知识

在采用动态规划时，总是用递归的思路分析问题，即把大问题分解成小问题，再把小问题的解合起来形成大问题的解。

找出描述大问题的解和小问题的解之间递归关系的**状态转移方程**是采用动态规划解决问题的关键所在。

可以采用**从上到下的递归法** 和 **从下到上的迭代法（常用数组存储答案）**

单序列问题、双序列问题、矩阵路径问题、背包问题

**从下到上的迭代法**：即从最小的子问题开始解决，然后通过小问题逐步合成大问题的解。

## 应用

- 088.爬楼梯的最少成本

  ```java
  // 方法一 ： 时间O（n），空间O（n）
  class Solution {
      public int minCostClimbingStairs(int[] cost) {
          // dp[i] 表示到达 i号阶梯需要的最小的体力
          int n = cost.length;
          int[] dp = new int[n + 1];
          dp[0] = 0;
          dp[1] = 0;
          for(int i=2;i<=n;i++)
          {
              dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
          }
          return dp[n];
      }
  }
  // 优化空间过后，时间O（n），空间O（1）
  class Solution {
      public int minCostClimbingStairs(int[] cost) {
          // dp[i] 表示到达 i号阶梯需要的最小的体力
          int n = cost.length;
          //int[] dp = new int[n + 1];
          //dp[0] = 0;
          //dp[1] = 0;
          int a = 0, b = 0;
          int ans = 0;
          for(int i=2;i<=n;i++)
          {
              ans = Math.min(a + cost[i - 1], b + cost[i - 2]);
              b = a;
              a = ans;
          }
          return ans;
      }
  }
  ```

  

### 单序列问题

- 089.房屋偷盗

  ```java
  class Solution {
      public int rob(int[] nums) {
          // dp[i] 表示以i号元素为结尾的能偷到的最大值，时间O（n^2）,空间O（n）
          int n = nums.length;
          int[] dp = new int[n];
          if(n == 1) return nums[0];
          if(n == 2) return nums[0] > nums[1] ? nums[0] : nums[1];
          dp[0] = nums[0];
          dp[1] = nums[1];
          for(int i=2;i<n;i++) // O（n^2）
          {
              int max = 0;
              for(int j = 0; j < i - 1; j++) // i - 1号不能偷
              {
                  max = Math.max(max, dp[j]);
              }
              dp[i] = max + nums[i];
          }
          int ans = 0;
          for(int i=0;i<n;i++) // 找最大的解
          {
              ans = Math.max(ans, dp[i]);
          }
          return ans;
      }
  }
  
  // f[i] 表示 从0~i的房屋为止最多能偷到的最大值。f[n - 1] 就是大问题的解
  // 方法二 时间O（n）空间O（1）
  // [2,1,1,2]
  class Solution {
      public int rob(int[] nums) {
          int n = nums.length;
          // int[] dp = new int[n];
          if(n == 1) return nums[0];
          if(n == 2) return nums[0] > nums[1] ? nums[0] : nums[1];
          // dp[0] = nums[0];
          // dp[1] = nums[0] > nums[1] ? nums[0] : nums[1];
          int a = nums[0];
          int b = nums[0] > nums[1] ? nums[0] : nums[1];
          int ans = 0;
          for(int i=2;i<n;i++)
          {
              ans = Math.max(b, a + nums[i]);
              a = b;
              b = ans;
          }
          return ans;
      }
  }
  ```

- 090.环形房屋偷盗

  最终的答案共有两种情况，选择最后一个元素，和不选最后一个元素

  思路：从下标为0的元素开始选择，不能选择下标为n-1的元素，区间是[0,n-2];

  ​			从下标为1的元素开始选择，可以选择下标为n-1的元素，区间是[1,n-1];

  ```java
  class Solution {
      public int fun(int[] nums, int start, int end)
      {
          int n = nums.length;
          int[] dp = new int[n];
          dp[start] = nums[start];
          dp[start + 1] = nums[start] > nums[start + 1] ? nums[start] : nums[start + 1];
          // int n = nums.length;
          for(int i = start+2; i <= end; i++)
          {
              
              dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
              // System.out.println(dp[i]);
          }
          return dp[end];
      }
      public int rob(int[] nums) {
          int n = nums.length;
          if(n == 1) return nums[0];
          if(n == 2) return nums[0] > nums[1] ? nums[0] : nums[1];
          
          // 选0就不能选最后，0~n-1,1~n
          int ans = 0;
          ans = fun(nums, 0, n - 2);
          ans = Math.max(fun(nums, 1, n - 1), ans);
          return ans;
      }
  }
  ```

  